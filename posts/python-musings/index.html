<!doctype html>
<html lang="en">
  <head>
		<!-- Required meta tags -->



<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

<title>Varun Suresh</title>
<meta name="author" content="" />
<meta name="description" content="Personal Website">

<link type="application/atom+xml" rel="alternate" href="varun-suresh.github.io/feed.xml" title="Varun Suresh">

<link rel="preload" as="font" type="font/woff2" crossorigin href="/assets/tufte-css/et-book/et-book-roman-line-figures/et-book-roman-line-figures.woff" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="/assets/tufte-css/et-book/et-book-display-italic-old-style-figures/et-book-display-italic-old-style-figures.woff" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="/assets/tufte-css/et-book/et-book-bold-line-figures/et-book-bold-line-figures.woff" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="/assets/tufte-css/et-book/et-book-roman-old-style-figures/et-book-roman-old-style-figures.woff" />




<link rel="stylesheet" href="/assets/main.css">
<link rel="stylesheet" href="/assets/tufte-css/tufte.min.css">
<link rel="stylesheet" href="https://use.fontawesome.com/3434e84155.css">
<!-- KaTeX Support -->
<link rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css"
      integrity="sha384-wcIxkf4k558AjM3Yz3BBFQUbk/zgIYC2R0QpeeYb+TwlBVMrlgLqwRjRtGZiK7ww"
      crossorigin="anonymous" />
<script defer
        src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js"
        integrity="sha384-hIoBPJpTUs74ddyc4bFZSM1TVlQDA60VBbJS0oA934VSz82sBx1X7kSx2ATBDIyd"
        crossorigin="anonymous"></script>
<script defer
        src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/contrib/auto-render.min.js"
        integrity="sha384-43gviWU0YVjaDtb/GhzOouOXtZMP/7XUzwPTstBeZFe/+rCMvRwr4yROQP43s0Xk"
        crossorigin="anonymous"
        onload="renderMathInElement(document.body);"></script>
<!-- BibTeX Support -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/pcooksey/bibtex-js@1.0.0/src/bibtex_js.min.js"></script>
<!-- Stylesheets -->
<link rel="stylesheet" href="/assets/tufte-css/tufte.min.css" />
<link rel="stylesheet"
      href="https://use.fontawesome.com/releases/v5.15.4/css/all.css" />
  </head>
  <body>
		<article>
		<h1>Python Musings
</h1>
		<p class="subtitle">Exploring and understanding the internal workings of python
</p>
				<section><h1 id="introduction">Introduction</h1><p>I have been writing Python for many years now, it is by far the most intuitive programming language I have used. However, every once in a while something seemingly obvious does not work as I’d expect.</p><p>In this post, I want to explore some of these gotchas and hopefully understand implementations in python better than I did before.</p></section>
<section><h2 id="pass-by-object-reference">Pass by object reference</h2><p>Consider the following functions</p><pre><code>from typing import List
def modify(x:int):
    x+= 1

def modify_list(x:List[int]):
    x.append(1)
</code></pre><p>The function <code>modify</code> takes in an integer x, modifies it <em>in-place</em> by adding 1. When I execute the following lines,</p><pre><code>x=5
modify(x)
print(x)

5
</code></pre><p>The value of x is unchanged although the operation we did was <strong>in-place</strong>.</p><p>However, when I run <code>modify_list</code>, the list is now updated.</p><pre><code>x = [1,2,3]
modify_list(x)
print(x)

[1,2,3,1]
</code></pre><p>When a mutable object like a list or a dictionary is passed to a function, it is passed by reference. If the object is modified, the change is reflected outside the function as well. When an immutable object like an integer or tuple is passed to a function, it is equivalent to passing by value.</p><pre><code>def modify_list(x:List[int]):
    x.append(5)
    x = [1,2]
x = [3,4]
modify_list(x)
print(x)

[3,4,5]
</code></pre><p>Although we are <em>re-assigning</em> x, the <code>x</code> re-assigned in the function<label for="md-to-learn-more-about" class="margin-toggle ">&#8853;</label><input type="checkbox" id="md-to-learn-more-about" class="margin-toggle" /><span class="marginnote">To learn more about python’s object reference, you can read this <a href="https://www.geeksforgeeks.org/is-python-call-by-reference-or-call-by-value/">post on geeksforgeeks</a></span> is in an entirely different memory location and its scope is only within the <code>modify_list</code> function.</p></section>
<section><h2 id="mutable-default-arguments">Mutable default arguments</h2><p>TL;DR - <strong>Do not</strong> use mutable objects as default arguments for a function.<label for="md-a-less-than-a-href" class="margin-toggle ">&#8853;</label><input type="checkbox" id="md-a-less-than-a-href" class="margin-toggle" /><span class="marginnote">A <a href="https://florimond.dev/en/posts/2018/08/python-mutable-defaults-are-the-source-of-all-evil">post</a> with a simpler example and a story of using mutable objects as a default argument in a function.</span></p><p>Consider the following implementation</p><pre><code>from typing import Dict
class TrieNode:
    def __init__(self, val:str,children:Dict[str,"Node"]={}) -> None:
        self.val = val
        self.children = children

node_1 = TrieNode("a")
node_2 = TrieNode("b")

node_1.children["c"] = TrieNode("c")
print(node_1.children.keys()) # Expect [c]
print(node_2.children.keys()) # Expect [] but get [c]
</code></pre><p>Although <code>node_1</code> and <code>node_2</code> are separate instantiations of the class <code>TrieNode</code>, they share the <code>children</code> attribute. The children attribute for both instances point to the same memory location because of the mutable dictionary object as a default argument in <code>__init__</code>.</p><p>The correct implementation would be as follows.</p><pre><code>from typing import Dict, Optional
class TrieNode:
    def __init__(self, val:str,children:Optional[Dict[str,"Node"]]=None) -> None:
        self.val = val
        if children:
            self.children = children
        else:
            self.children = {}
</code></pre><p>In this implementation, the children attribute is initialized inside the class, so for every instantiation of this class, the <code>children</code> will be saved in a separate location.</p></section>
<section><h2 id="list-implementation">List implementation</h2><p>In Python, a list is implemented as a dynamic array. A contiguous block of memory is initially assigned to a list. If the size of the list exceeds this size, a new block that is <code>k</code> times the original size is assigned where k > 1. Adding a new element to an array is a O(1) operation amortized. When an element added to the list causes the list size to increase, all the elements in the list need to be copied to this new block of memory making it a O(n) time complexity operation.</p><p>How are the elements of an list <em>actually</em> stored? Note that not all elements in an array need to be of the same type and each<label for="md-for-example-a-list" class="margin-toggle ">&#8853;</label><input type="checkbox" id="md-for-example-a-list" class="margin-toggle" /><span class="marginnote">For example, a list like <code>x = [1,2,3,"randomstring",5.3]</code> is a valid list.</span>element could take up different amounts of memory as in the example below.</p><pre><code>import sys
x = [1,2,3]
print(sys.getsizeof(x))
x = [1,2,"Very long block of text"]
print(sys.getsizeof(x))

88
88
</code></pre><p>The result is the same in both cases, even though <code>Very long block of text</code> should take up more bytes than <code>3</code>. That is because only the references (address of the memory location + offset) to the elements are stored in the list. It is not that all the elements in the list are stored in contiguous locations (like in C, C++ arrays), but their references are stored sequentially.</p></section>
<section><h2 id="numpy-learnings">Numpy learnings</h2><p>Numpy is a python library that speeds up vector and matrix operations. Under the hood, numpy runs C code to execute operations. C loops are significantly faster than Python loops and hence there is a significant speedup when numpy is used instead of python lists.</p><h3 id="numpy-ndarray">Numpy ndarray</h3><p>ndarray stands for n-dimensional array. There are two main components to a ndarray - data buffer and metadata. The data buffer is the contiguous memory block that stores the actual array data. The metadata contains information like the data type, shape of the array etc. Let’s say you wanted to transpose a matrix. Numpy internally does not change the data buffer, instead it modifies the meta data to indicate how the data should be read. </p><p><strong>Gotchas to be aware of</strong></p><p>Consider an example where you slice an array</p><pre><code>import numpy as np

a = np.array([1,2,3,4])
b = a[0:2] # b -> [1,2]
c = a[[0:2]]
a[0:2] = [5,6]
print(b) # Expected: [1,2], Actual result: [5,6]
print(c) # [1,2]
</code></pre><p>This is because <em>b</em> is merely a view of <em>a</em>, <em>b</em> still points to the same data buffer as <em>a</em>. <em>c</em> however creates an explicit copy.<label for="sd-less-than-a-href" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sd-less-than-a-href" class="margin-toggle" /><span class="sidenote"><a href="https://numpy.org/doc/stable/dev/internals.html#numpy-internals">Internal organization of NumPy arrays</a></span></p><h3 id="broadcasting">Broadcasting</h3><p>Using numpy to multiply a scalar to a vector or a matrix is extremely straightforward. For example</p><pre><code>import numpy as np
a = np.array([1,2,3])
b = 3
print(a*b) # np.array([3,6,9])
</code></pre><p><em>a</em> is an array of shape (1,3) and <em>b</em> is a scalar. When the two are multiplied, <em>b</em> is “streched” to be the same size as <em>a</em> and numpy multiplies it point-wise. Consider another example where we want to multiply each row of a matrix by a different number</p><pre><code>import numpy as np
a = np.array([[1,2],[3,4],[5,6]]) # Shape: 3x2
b = np.array([10,20,30]) # Shape: (3)
print(a*b) # Raises a dimensional mismatch error
print(a*b[:,np.newaxis]) # Now b is a (3,1) shaped array -> np.array([[10,20],[60,80],[150,180]])
</code></pre><p>Numpy can perform operations on two arrays when either their dimensions are equal or one of the two corresponding dimensions is 1. <label for="sd-less-than-a-href" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sd-less-than-a-href" class="margin-toggle" /><span class="sidenote"><a href="https://numpy.org/doc/stable/user/basics.broadcasting.html">Numpy broadcasting</a></span></p></section>

		</article>
		<footer>
  <p class="social-links">
    <a href="/"><span class="fas fa-home"></span></a>
    
    &nbsp
    
    
    
    
    <a href="https://github.com/varun-suresh"><span class="fab fa-github-square"></span></a>
    
    <a href="https://linkedin.com/in/varunsuresh"><span class="fab fa-linkedin-square"></span></a>
    <a href="mailto:fab.varun@gmail.com"><span class="fab fa-envelope-square"></span></a>
    &nbsp
    
    <a href="/search"><span class="fas fa-search"></span></a>
  </p>
</footer>
  </body>
</html>
